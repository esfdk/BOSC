\chapter{Opgavebesvarelse}
\section{Forord}
I denne rapport dokumenterer vi vores valg i forhold til implementationen af opgaverne i Obligatorisk opgave 2.
\\Vores implementation kan findes i "".

Kildekode og testdokumentation kan findes i appendix på side \pageref{Appendix}. Vores git repository kan findes på https://github.com/esfdk/BOSC .

\section{}

\section{Beskrivelse af implementation}
\subsection{Opgave 1}
\label{O1}

\subsubsection{Del 1}
\label{O1_1}

\subsubsection{Del 2}
\label{O1_2}
I opgave 1.2 bliver vi bedt om at tjekke vores multitrådet sum funktion vha. en speedup graf.
En speedup graf visser hvor hurtigere en funktion bliver når man tildeler den flere tråde. 
indæst speedup funktion her\n\n
Speedup udregnes ved at tage kørselstiden ved 1 tråd og dividere det med kørselstiden med n tråde i vores tilfælde 1-2-4-6-8. Det optimalle resultat ville være linær speedup hvor speedupen er lige antallet af tråde funktionen er blevet kørt med.
indsæt ideal speedup graf

\paragraph{Valg af maskine til speedupgraf}
Til test af vores multitrådet sum funktion havde vi valgte mellem en to,fire eller otte processors computer. Vi valgte at bruge computeren med fire processor. Det gjorde vi fordi det var medianen og vi mente, at det var hvad en standart computer ville have og vi derfor ville få nogle generelle resultater. 

\subparagraph{Uventet resultat ved kørsel med fire tråde}
indsæt speedup graf her \n\n
Som vi kan se udfra vores speedup graf er der næsten en ideal speedup fra en tråd til to tråde, men ved fire tråde bliver den kun en smule hurtigere end ved en tråd. Dette resultat synes vi er fovirrende da det også burde være muligt at få en speedup tilsvarende processoren da computer trods alt har fire realle processor. Vi har ingen forklaring på hvorfor dette er sådan. 
Vi havde forventet at få problemer ved seks og otte da vi ikke har mulighed for at tildele hver tråd en processer og det derfor bliver mere besværligt at oprette og styre dem. 
indsæt melnyk speedup graf her \n\n
Vi har kort testet vores funktion på en laptop med 4 processor og hyperthreading hvor vi havde en normal speedup optil fire tråde hvilket er forståligt da 4 processor med hyperthreading kun 'simulere' 8 processor, og derfor sikkert ikke arbejder ligeså optimalt som 8 konkrete processor.

\subsubsection{Tests}
\label{O1_Tests}


\subsection{Opgave 2}
\label{O2}

\subsubsection{Del 1}
\label{O2_1}
Vi har valgt at implementere list_add(List *l, Node *n) på en meget simpel måde (se linje 35 til 41 i list.c). Listens sidste element ('l->last') bliver sat til at pege på den nye node ('l->last->next = n'), hvorefter 'l->last' bliver sat til at være n. På denne måde vil det anden sidste element pege på det nye element, og 'last' peger på det nye element, da det er det sidste i listen.
\\*list_remove(List *l) implementationen kan ses på linje 44 til 60 i list.c filen. I funktionen bliver der lavet en 'Node *n'. Denne node bliver sat til at være det første element i listen, altså 'l->first->next' da 'first' er root elementet og aldrig skal pilles ved. Rodelementets 'next' bliver sat til at pege på n's 'next', hvilket er det andet element i listen. På denne måde er det første element blevet "fjernet" fra listen. Funktionen tjekker derefter om 'first->next' er null, for hvis den er, skal 'last' pege på først, ligesom da listen lige var blevet lavet. Til slut retuneres n.

\subsubsection{Del 2}
\label{O2_2}
Det mest åbenlyse problem er, at flere tråde kan editere listen på samme tid. For eksempel: To tråde tilgør listen på samme tid og finder frem til det sidste element ('last'). Begge tråde prøver at tilføje et element til listen, hvilket betyder at de begge prøver at tilføje et element til 'last' på samme tid. Tråd #1 tilføjer sit element til 'last', hvorefter tråd #2 tilføjer sit element til 'last' (det element som #1 lige har tilføjet sit element til), hvilket ødelægger linket mellem 'last' og tråd #1s element.
\\En anden udgave af problemet ovenover er, hvis to forskellige tråde vil remove på samme tid. Tråd #1 går ind og læser 'first's 'next' element (da det skal blive first efter removal). Samtidig går tråd #2 ind og kører hele removal, hvorefter #1 prøver at fjerne det element der lige er blevet fjernet. Derved er kun et element blevet fjernet, hvor to elementer burde have været fjernet. Den omvendte situation kan også opstå, hvor to elementer bliver fjernet, men hver tråd tror kun at et element er blevet fjernet.
\\Alt efter størrelsen af listen kan der også opstå problemet. Hvis listen kun er et element langt og en tråd prøver at adde mens en anden prøver at remove, kan der opstå forkerte resultater. Sker de samtidig, kan elementet blive addet (hvilket gør at listen er to elementer lang), på samme tid som det første (og eneste) element bliver removet. Risikoen er, at det nye element bliver appendet på det element der lige er blevet removet, hvorved ingen af elementerne er i listen.

\subsubsection{Del 3}
\label{O2_3}
Vi har brugt mutex låse i list_add og list_remove funktionerne. I list_add er de to linjer logik inde i en mutex lock, da det ikke skal være muligt for flere tråde, at tilføje elementer på samme tid. I list_remove er alt undtagen return-statementet indkapslet af mutex locks af samme årsag som i list_add; det skal ikke være mulgit at fjerne flere elementer samtidig. At 'return n' ikke er i en lock, gør dog ingen skade. Når funktionen når til 'return', bruger den ikke listen mere, og det kan derfor køres uden at være i en lock.
Vi har beskrevet vores test at den flertrådet liste i afsnit \ref{02_Tests}.

\subsubsection{Tests}
\label{O2_Tests}
Vi har lavet to tests til first-in-first-out listen. En test uden brug af tråde for at se om lsiten overhovedet virker, og en test med tråde, for at sikre at flere tråde kan bruge listen samtidig, uden der opstår problemer.
\\Testen uden brug at tråde findes i testNoThreads.c. I denne test laver vi en liste, tilføjer to elementer til listen, fjerner to elementer fra listen og printer deres værdier for at sikre os, at de er kommet ud i den rigtige rækkefølge. 
\\Testen med tråde findes i testThreads.c og er lidt mere omfattende. Testen tager to parametre: Antallet af tråde der skal laves, og antallet af elementer hver tråd skal håndtere. 'main' funktionen laver et array med det valgte antal tråde, og sætter dem alle samme til at køre '*TaskCode(void *argument)' funktionen. Hver tråd får sit eget nummer i arrayet med, for at man nemmere kan holde styr på hvilken tråd der gør hvad. Hver tråd laver det valgte antal elementer (som er strings med formatet ("Thread \#\%d, element \%d", threadNumber, elementNumber)) og adder dem til listen. Derefter fjerner tråden det antal elementer, som den har addet til listen og printer værdien af disse elementer. 
\\Det man kan se med testThreads testen er, at trådene går ind og låser listen når de bruger den. Som oftest vil elementerne være i rækkefølge, så det er alle tråd et's elemnter først, så tråd to's, osv.

\subsection{Opgave 3}
\label{O3}
I denne opgave har vi brugt 'pthread_mutex_t' objekter til at undgå problemer hvor flere tråde ændrer samme element på samme tid. 'pthread_mutex_t' er objekter, der kan låses/låses op via 'pthread_mutex_lock'-funktions kaldet. Hvis en funktion låser en mutex, forhindre den derved andre funktioner i at køre videre, forudsat at de selv skal bruge mutex'en. De andre funktioner går i stå indtil mutex'en låses op igen, hvilket sørger for at critical kode kun køres af en tråd ad gangen. Bruger man ikke mutex låse i et flertrådet program, risikerer man at løbe ind i situationer hvor flere tråde har modificeret samme element på samme tid, hvilket kan ødelægge programmet.
\\ Vi har også brugt 'sem_t' objekter, også kaldet semaphore. Det er objekter, der indeholder en værdi, og som kan bruges af funktioner til synkronisation mellem tråde. De har to interessante funktioner: 'sem_wait(sem_t)' og 'sem_post(sem_t)'. 'sem_wait()' kigger på værdien af semaphoren. Hvis værdien er mindre end nul, vil den kaldende funktion pause, og vente på værdien bliver højere end nul. Når det sker, vil den kaldende funktion få lov til at køre videre og 'sem_wait()' reducerer værdien af semaphoren med en. 'sem_post()' forøger simpelthen bare værdien af semaphoren med en.
\\ Både 'phtread_mutex_t' og 'sem_t' objekter virker som låse, omend på forskellige måder. 'pthread_mutex_t' virker som en ja/nej, og vil kun lade en tråd udføre sit arbejde ad gangen. 'sem_t' lader gerne flere tråde arbejde på samme tid, så længe semaphorens værdi er over nul.

\subsubsection{Opfyldelse af punkter}
\label{O3_Punkter}
\paragraph{Punkt 1} - Vores implementation gør det muligt at definere antallet af producers, antallet af consumers, størrelsen på bufferen og antallet af produkter der skal produceres. Dette gør vi, ved først at tjekke om der er den rigtige mænge inputs, hvorefter vi konveterer inputs til ints og bruger dem til at lave de forskellige ting (se linje 36-48).
\paragraph{Punkt 2} - Punkt 2 opfyldes af koden. Vi har kun en producer funktion og en consumer funktion (henholdsvis linje 120 og 160), og consumer/producer tråde laves og sættes til at køre det respektive kode (se linje 84-104).
\paragraph{Punkt 3} - Både producer funktionen og consumer funktionen kalder 'sleepRandom' funktionen hver gang de udfører deres logik (se linje 155 og 188), som sætter tråden til at sove i et tilfældigt antal sekunder (se linje 214-221).
\paragraph{Punkt 4} - Vi sørger for at tråde ikke udsultes ved at lade tråde sove i et tilfældigt antal sekunder, når de har arbejdet. På denne måde forhindrer vi tråde i at tage alle opgaverne og derved udsult andre tråde.
\paragraph{Punkt 5} - Se afsnit \ref{O3_Output} i Appendix for output.
\paragraph{Punkt 6} - Vi opfylder dette krav igennem et tjek i starten af både consumer og producer funktionerne. I starten af producer funktionen, tjekkes der om der stadig skal produceres flere produkter. Hvis der ikke skal, afsluttes producer tråden. Consumeren tjekker, om der er konsumeret lige så mange produkter som skulle produceres. Hvis der er, afsluttes consumer tråden

\subsubsection{Implementation}
\label{O3_Implementation}
Vores implementation af Producer-Consumer opgaven består af fem funktioner, der tilsammen løser kravene til opgaven. De fem funktioner er beskrevet hurtigt her, og vi går mere i dybden med dem længere nede: 
\begin{my_enumerate}
    \item 'main(int argc, char* argv[])' - Main funktionen læser de valgte parametre fra command line, initialiserer de forskellige objekter og holder styr på trådene.
    \item '*producer(void *argument)' - Producer funktionen indeholder koden, som en producer tråd skal udføre. 
    \item '*consumer(void *argument)' - Consumer funktionen indeholder koden, som en consumer tråd skal udføre. 
    \item '*produceProduct()' - ProduceProduct funktionen bruges af producer tråde til at lave et nyt produkt.
    \item 'sleepRandom(float wait_time_ms)' - SleepRandom funktionen sætter tråden der kalder den til at sove i en tilfældig mængde tid baseret på inputtet.
\end{my_enumerate}

\\Udover disse fem funktioner, er der en del forskellige variabler. Vi bruger tre forskellige locks til at undgå multi-thread problemer; 'produce_lock', 'consume_lock' og 'products_buffer_lock'. 'produce_lock' bruges når et nyt element bliver produceret og føjet til listen. 'consume_lock' bruges når et element skal konsumeres. 'products_buffer_lock' bruges når antallet af elementer i listen skal tælles op/ned.
\\Vi bruger også tre semaphores: 'empty', 'full' og 'products_remaining'. 'empty' bruges til at fortælle hvor mange pladser der er tilbage i bufferen. 'full' bruges til at fortælle hvor mange pladser der er i brug. Hvis værdien af disse to semaphore ligges sammen, får man størrelsen på bufferen. 'products_remaining' bruges til at holde styr på hvor mange produkter der stadig skal produceres.
\\Programmet indeholder endvidere følgende syv int variabler: 'number_of_producers', 'number_of_consumers', 'total_number_of_products', 'produced_products', 'consumed_products', 'products_in_buffer', 'buffer_size'. Da de alle har sigende navne, behøver de ikke nogen forklaring.

\subsubsection{Gennemgang af funktioner}
\label{O3_Funktioner}
'main'-funktionen sørger for at hele programmet starter. Den starter med at læse argumenterne ind fra command line, hvorefter den sætter værdierne af 'number_of_producers', 'number_of_consumers', 'total_number_of_products' og 'buffer_size' til det givne input (linje 36-48). Funktionen initaliserer herefter de tre semaphore, listen der skal indeholde produkterne, de tre mutex locks og to 'pthread_t' arrays som holder producer/comnsumer trådene (linje 51-85). Funktionen slutter af med at lave producer/computer trådene og joine dem (linje 88-114)
\\ 'producer'-funktionen tager imod en 'void *argument' parameter, som den caster til en int, som tråden bruger som identifikationsnummer (linje 122). Funktionen begynder derefter en uendelig løkke, hvori den udfører sin logik. Hver producer venter på semaphoren 'products_remaining', for at finde ud af om der stadig skal procuderes produkter (linje 128). Hvis der ikke skal laves flere produkter, afsluttes tråden (linje 129-132). Hvis der stadig skal laves produkter kaldes 'produceProduct'-funktionen (linje 133-136), som laver et produkt og gemmer det i tråden's node objekt. Produceren venter derefter på, at der er plads i listen, hvorefter den adder produktet til listen (linje 143-144). Produceren låser herefter 'products_buffer_lock', tæller 'products_in_buffer' en op og låser 'products_buffer_lock' op igen og skriver at den har tilføjet produktet (linje 147-150). Dette gøres for at undgå at flere tråde ændrer på 'products_in_buffer' på samme tid, hvilket kan give forkerte tal, når der printes til command line. Til slut signalerer produceren 'full' (hvliket forøger 'full's værdi med en) og ligger sig til at sove i en tilfældig mængde tid via 'sleepRandom'-funktionen.
\\ 'comsumer'-funktionen tager også en 'void *argument' parameter og caster den til en int, som bruges til identifikation af consumeren (linke 162). Consumeren begynder en uendelig løkke, hvori dens logik udføres. Den låser 'consume_lock', for at undgå problemer med at flere consumers prøver at konsumere produkter samtidig (linje 166). Den tjekker dernæst, om der er produceret alle de produkter der skal produceres. Hvis der er, afsluttes tråden (linje 168-172). Hvis det ikke er tilfældet, venter den på, at der er et produkt i bufferen. Når et produktbliver lagt i bufferen, fjerner consumeren det (linje 174-175). Efter at have fjernet produktet, låser consumeren 'products_buffer_lock', tæller 'products_in_buffer' en ned og låser 'products_buffer_lock' op igen (linje 178-180). 'consumed_products' tælles derefter op, for at trådene før eller siden afsluttes. 'consume_lock' låses op igen og semaphoren 'empty' bliver forøget med en, for at føre opmærksom på, at der er plads i bufferen igen (linje 182-184). Til slut fortæller consumeren hvad den har konsumeret, hvorefter den ligger sig til at sove via 'sleepRandom'.
\\ 'produceProduct'-funktionen bruges af producers, når de skal lave nye produkter. Funktionen låser 'produce_lock', for at forhindre at flere produkter bliver lavet på samme tid, da der ellers kan opstå problemer (linje 198). Der bliver lavet en string med formatet ("ITEM_\%d", produced_products) og 'produced_products' bliver talt en op (linje 201-204). 'produce_lock' låses op igen, funktionen laver en node baseret på den string der lige blev lavet, og noden bliver retuneret (linje 206-210).
\\ 'sleepRandom'-funktionen tager en 'float wait_time_ms' parameter, som den laver et random tal ud fra. Funktionen genererer et seed ud fra tidspunket på dagen, og laver derefter et random tal ud fra seedet og 'wait_time_ms'. Til slut kalder funktionen 'usleep', hvilket får tråden til at sove i den udregnede mængde tid (linje 216-220). Grunden til der genereres et seed til random-funktionen er, at ellers ville det samme seed bruges hver gang, hvilket ville ødelægge ideen med tilfældighed.

\subsubsection{Tests}
\label{O3_Tests}

\subsection{Opgave 4}
\label{O4}


\subsubsection{Tests}
\label{O4_Tests}
